import random
import sys
import math

def mh_sample(seq,num_samples,a,a_0,b):
	num_symbols = max(seq) + 1
	old_machine = PDFA(num_symbols,a,a_0,b)
	pdfas = []
	scores = []
	numstates = []
	for t in range(num_samples):
		machine = old_machine.deepcopy()
		for pair in old_machine.t:
			if pair in machine.t:
				for i in range(R): # sample multiple possible assignments for this state/symbol transition given the rest of the transitions
					new_machine = machine.deepcopy()
					new_machine.removepair(pair)
					counts = new_machine.count(seq) # since only pair has been changed, the sequence must visit this pair at least once and pick a new following state
					score = new_machine.score(counts)
					if math.log(random.random()) < score - scores[-1]: # accept the sample
						machine = new_machine
						map(machine.removepair,[x for x in counts if counts[x] == 0])
						scores.append(score)
					else:
						scores.append(scores[-1])
					numstates.append(machine.numstates())
		if t % 10 == 9:
			pdfas.append(machine)
		old_machine = machine
	return [pdfas, scores, numstates]

class PDFA:
	def __init__(self, num_symbols=2, a=None, a_0=None, b=None): # if any of the hyperparameters are set to None, place a vague Gamma prior on them and sample
		self.S = num_symbols
		self.t = {} # maps a state/symbol tuple to a table index in that restaurant
		self.n = [{} for i in range(self.S)] # maps a table index to the count at that table
		self.k = [{} for i in range(self.S)] # maps a table index to the table index in the high-level restaurant
		self.m = {} # maps a high-level table index to a count
		self.alpha = a
		self.alpha_0 = a_0
		self.beta = b
        
	def numstates(self):
		return len([i for i in self.m if self.m[i] != 0])

	def add(self,state,symbol,next_state=None,next_table=None): # If next_state is not given, sample new state according to CRF.  Else, assign a table by conditioning on next_state.
		if next_state == None:
			if next_table == None:
				table = crp(self.n[symbol],self.alpha)
			else:
				table = next_table
		else:
			dish = next_state
			if next_table != None:
				table = next_table
			elif next_state in self.m:
				prob = dict([(i,self.n[symbol][i]) for i in self.n[symbol] if self.k[symbol][i] != next_state]) # counts the number of times a customer sits at a table serving the dish next_state
				prob[gensym(prob)] = self.alpha * self.m[next_state] / ( sum(self.m.values()) + alpha_0 ) # probability of seating a customer at a new table *and* that table serving dish next_state
				table = discrete_sample(prob)
			else:
				table = gensym(self.n[symbol])
		self.t[(state,symbol)] = table
		if table in self.n[symbol]:
			self.n[symbol][table] += 1
		else:
			self.n[symbol][table] = 1
			if next_state == None:
				dish = crp(self.m,self.alpha_0)
			self.k[symbol][table] = dish
			if dish in self.m:
		       		self.m[dish] += 1
		       	else:
		       		self.m[dish] = 1
                
	def addpair(self,pair,next_state=None,next_table=None):
		self.add(pair[0],pair[1],next_state,next_table)
                
	def remove(self,state,symbol):
		if (state,symbol) in self.t:
			table = self.t[(state,symbol)]
			del self.t[(state,symbol)]
			self.n[symbol][table] -= 1
			if self.n[symbol][table] == 0:
				dish = self.k[symbol][table]
				del self.n[symbol][table]
				del self.k[symbol][table]
				self.m[dish] -= 1
				if self.m[dish] == 0:
					del self.m[dish]

	def removepair(self,pair):
		self.remove(pair[0],pair[1])

	def next(self,state,symbol):
		if (state,symbol) not in self.t:
			self.add(state,symbol)
		return self.k[symbol][self.t[(state,symbol)]]

	def run(self,seq,start_state=0): # returns a generator that iterates over the states the machine traverses given a sequence (creating new states as need be)
		state = start_state
		for i in seq:
			yield state
			state = self.next(state,i)

	def count(self,seq,start_state=0):
		history = zip([state for state in self.run(seq,start_state)],seq)
		return dict((i,history.count(i)) for i in self.t)

	def score(self,counts): # Returns the log likelihood of the sequence given the PDFA.  I should double-check for the particle filter case that it's ok to average these.
		state_counts = dict([(i,sum(counts[j] for j in counts if j[0] == i)) for i in self.m]) # the total number of times a state is visited
		return sum([math.lgamma(x + self.beta/self.S) - math.lgamma(self.beta/self.S) for x in counts]) - sum([math.lgamma(y + self.beta) - math.lgamma(self.beta) for y in state_counts])
        
	def scoreseq(self,seq,start_state=0):
		return self.score(self.count(seq,start_state))

def crp(rest,alpha):
       	prob = rest.copy()
       	prob[gensym(prob)] = alpha
       	return discrete_sample(prob)

def discrete_sample(p):
       	sample = sum(p.values()) * random.random()
       	for x in cumsum(p):
       		if x[1] >= sample:
       			return x[0]
	return None
    
def even(n):
	state = 0
	for i in range(n):
		if state == 0:
			if random.randint(0,1) == 0:
				yield 0
			else:
				state = 1
				yield 1
		else:
			state = 0
			yield 1

def cumsum(x):
	sum = 0
	for i in x:
		sum += x[i]
		yield (i,sum)

def gensym(x): # generates a random number not already in x
	while True:
		rand = random.randint(1,sys.maxint)
		if rand not in x:
			return rand
